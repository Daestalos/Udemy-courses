


// <--------------- Лексическое окружение --------------->
// в JS у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний объект, который называется лексическое окружение

// Лексическое окружение делится на внутреннее и на внешнее

// Environment Record (Внутреннее) – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this).

// Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).

// "Переменная" – это просто свойство специального внутреннего объекта: Environment Record. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».


// <------------------ ЗАМЫКАНИЯ -------------------->
// Замыкание - это когда функция пытается найти что-то внутри себя (допустим какой-то number) и если она этого не находит, то она обращается к чему-то, что находится более глобально


"use strict";

let number = 5; 

function logNumber(){
    let number = 4;
    console.log(number);
}

number = 6;

logNumber(); // = 6

// Каждый вызов функции - это создание нового лексического окружения со соими споецифичными для этого вызова локальными переменными и параметрами

// пример

function createCounter() {
    let counter = 0;
    const myFunction = function () {
        counter = counter+1;
        return counter;
    }
    return myFunction;

}

const increment = createCounter();
const c1 = increment();
const c2 = increment();
const c3 = increment();

console.log(c1, c2, c3);

// Когда вы объявляете новую функцию и присваиваете её переменной, то в этой переменной вы храните не только определение функции, но и её замыкание. Замыкание содержит все переменные, которые находятся в области видимости во время создания функции. Это аналогично рюкзаку. Определение функции идёт вместе с маленьким рюкзаком. А хранятся в нём все переменные, которые были в поле видимости в то время, когда функция создавалась.
// Строки 1–8. Мы создаём новую переменную createCounter в глобальной области выполнения и присваиваем ей описание функции. Так же, как и раньше.
// Строка 9. Мы объявляем новую переменную increment в глобальной области выполнения. Так же, как и раньше.
// Снова строка 9. Нам нужно вызвать функцию createCounter и присвоить возвращённое ей значение переменной increment. Так же, как и раньше.
// Строки 1–8. Вызываем функцию. Создаём новую локальную область выполнения. Так же, как и раньше.
// Строка 2. В локальной области выполнения объявляем новую переменную counter. Число 0 присваивается counter. Так же, как и раньше.
// Строки 3–6. Объявляем новую переменную myFunction. Эта переменная объявлена в локальной области выполнения. Пока что контентом этой переменной является описание другой функции. Эта функция описана в строках 4 и 5. Но также мы создаём замыкание, которое является частью функции. Замыкание хранит переменные из своей области видимости. В нашем случае это переменная КАУНТЕР (значение которой 0).
// Строка 7. Возвращаем содержимое переменной myFunction. Локальная область выполнения удалена. myFunction и counter больше не существуют. Управление возвращено вызвавшей области. Таким образом мы возвращаем описание функции и её замыкание, рюкзак с переменными, которые были в области видимости во время её создания.
// Строка 9. В вызвавшей области, глобальной области выполнения, значение, возвращаемое функцией createCounter присвоено переменной increment. Переменная increment теперь содержит определение функции (и замыкание). Определение функции, которое было возвращено из createCounter. Она больше не называется myFunction, но имеет то же определение. В глобальной области она называется increment.
// Строка 10. Объявление новой переменной c1.
// Строка 10 (продолжение). Смотрим на переменную increment. Это функция. Вызываем её. Она содержит определение функции, которое было возвращено ранее и было описано в строках 4-5 (в которой также хранится и рюкзак с переменными).
// Создаём новую область выполнения. Без параметров. Начинаем выполнение функции.
// Строка 4. counter = counter + 1. Ищем переменную counter. Перед тем, как поискать в локальной или глобальной области выполнения, давайте посмотрим в нашем рюкзаке. Проверяем замыкание. Оказывается, замыкание содержит переменную counter со значением 0. После выражения на строке 4 её значение установлено в 1. И она снова хранится в рюкзаке. Теперь замыкание хранит переменную counter со значением 1.
// Строка 5. Мы возвращаем значение переменной counter, а именно число 1. Мы уничтожаем локальную область выполнения.
// Возвращаемся к строке 10. Возвращённое значение (1) присвоено c1.
// Строка 11. Мы повторяем шаги 10–14. В этот раз, когда мы посмотрим в нашем замыкании, то увидим, что переменная counter хранит значение 1. Оно было задано в 12-ом шаге, или на 4-ой строке программы. Это значение было увеличено и сохранено как 2 в замыкании инкремент-функции. Таким образом c2 присваивается 2.
// Строка 12. Мы повторяем шаги 10–14, c3 получает значение 3.
// Строка 13. Мы выводим в консоль значения переменных c1, c2 и c3.
// Теперь мы понимаем как это работает. Ключевое понятие, которое нужно запомнить, это то, что когда функция объявляется, то она содержит описание функции и замыкание. Замыкание — это коллекция всех переменных из области видимости во время создания функции.



