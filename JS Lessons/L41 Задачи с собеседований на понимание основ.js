"use strict";


// <--------------------Задача 1------------------------>
let x = 5;
console.log(x++); // =5
// будет 5 так как стоит постфиксная форма, если было бы ++x, то было бы 6


// <----------------------Задача 2-------------------------->
// [] + false - null + true
console.log([] + false); // = false
console.log(typeof([] + false)); // =string
// false у нас будет строкой, так как когда мы работаем с пустым массивом в таких операциях, он у нас будет преведет к строкому типу данных, а именно к пустой строке, тоже самое ("" + false)

console.log([] + false - null) // = NaN, именно такое значение мы видим при выполнении не математических операций, в данном случае от строки отнимаем null

console.log([] + false - null + true); // = NaN


// <---------------------Задача 3--------------------------->
let y = 1;
let x1 = y = 2; // сначала 2 присваивается y, а потом x
console.log(x1); // = 2

// <---------------------Задача 4--------------------------->
console.log([] + 1 + 2); // = 12
// так как пустой массив в такой операции равен "", то у нас происходит конкатенация с 1, т.е. становится "1" + 2 и соответственно мы прибавляем строке число и получаем "12"; 

// <---------------------Задача 5--------------------------->
console.log("1"[0]); // = 1
// мы обращаемся к 0 символу строки "1"
console.log("1234"[2]); // = 3

// <---------------------Задача 6--------------------------->
console.log(2 && 1 && null && 0 && undefined); // = null
// оператор && всегда запинается на лжи
// когда оператор обрабатывает все аргументы, которые мы ввели, он идет слева-направо, т.е. сначала смотрит 2, это правдивое выржаение, 1 тоже, дальше null, это значение всегда дает false
// и так как оператор && впервые запнулся на чем-то ложном, то он его и будет возвращать, дальше код не пойдет

// аналогичная ситуация у оператора или ||, только он всегда запинается на правде
console.log( null || 2 || 1 ||  0 ||  undefined); // = 2

// <---------------------Задача 7--------------------------->
// есть ли разница между этими двумя выражениями !!(a && b) и (a && b)
console.log(!!(1 && 2)); // true
console.log(1 && 2); // 2
// два этих выражения не равны, так как впервом случае !! приводит к булевому типу данных, а во втором у нас числовой
console.log(!!(1 && 2) === (1 && 2)); // = false


// <---------------------Задача 8--------------------------->
//	Что выведет этот код: alert( null || 2 && 3 || 4 ); ?
// в данном примере нужно смотреть на приоритетность операторов
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence
//                      3
console.log( null || 2 && 3 || 4 ); // = 3
// выражение равняется 3, так как сначала по приоритетности выполняется && слева-направо, когда у нас оба аргумента при логическом сравнении && равны, то у нас данный оператор возвращает последнее значение, оно правдиво
// далее сравниваем null || 3, ||  всегда запинается на правде, соответсвенно = 3
// и соответсвенно 3 || 4 -- 3

// <---------------------Задача 9--------------------------->

// равняется ли массив a массиву b
const a = [1,2,3];
const b = [1,2,3];

console.log(a === b); // false
// Хоть элементы и одинаковы у этих массивов, но мы сравниваем не них, а сами массивы. False потому что это абсолютно разные массивы, если бы мы сравнимали элементы, то тогда было бы true

// <---------------------Задача 10--------------------------->
console.log(+'Infinity'); // = Infinity

// <---------------------Задача 11--------------------------->
console.log(0 || "" || 2 || undefined || true || falsе ); // =2
// И запинается всегда на правде, 2 это правда