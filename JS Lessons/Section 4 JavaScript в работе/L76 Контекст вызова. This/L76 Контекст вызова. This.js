'use strict';

// Контекст вызова функции - это то, что окружает функцию и в каких условиях она вызывается
// Например: Человек без определенного места жительства, в таком случае этот человек функционирует в пределах всего мира, у него нету какой-то привязки к определенному месту, но если мы поместим его в спец. учреждение, где он сможет жить и чем-то заниматься, то он получит так называемый контекст вызова, теперь у него есть свое место для функционирования. Функции в JS ведут себя точно так же


// <--------------------------------------- This ------------------------------------------->

function showThis () {
    console.log(this); // window (наш глобальный объект)
} 

showThis(); // Если функция просто запускается вот таким, когда мы используем в ней контекст, то этот контекст будет ссылаться на глобальный объект window. Это правильно верно для обычного кода без строгово режима
// но если у нас включен строгий режим this будет undefiend

// 1) Обычная функция: this = window, но если стоит use strict = undefiend

// пример:
function show(a, b){
    console.log(this); // = undefiend
    function sum(){
        // 1 вопрос: что выведет консоль лог
        console.log(this); // = undefiend, так как неважно где эта функция запускается, самое главное, что у нее контекст вызова точно так же будет либо window, либо undefiend
        // 2 вопрос: будет ли работать return и если нет, то как его исправить
        // Чтобы это сработало достаточно использовать замыкание функции, убрав this
        // return this.a + this.b; // = NaN
        return a + b;
        // В данном случае замыканием является то, что когда мы запускаем такой код, она ищет a и b в sum, не находит их и идет в функцию show, чтобы их найти
    }
    console.log(sum());
}

show(2,4); // = 6

// 2) Методы объектов это тоже функции. Если мы используем метод внутри объекта, то контекст вызова всегда будет ссылаться на этот объект

// Пример:

const obj = {
    a: 20,
    b: 15,
    thisObj() {
        console.log(this);
    },
    sum(){
        console.log(this.a+this.b);
    },
    shot(){
        function shout(){
            console.log(this);
        }
        shout();
    }
};

obj.thisObj(); // = { a: 20, b: 15, sum: [Function: sum] }
obj.sum(); // 35
obj.shot(); // = undefiend, так как shout простой вызов функции, он уже не относится к объекту, это не метод объекта, это функция, которая уже запускается внутри метода, контекст вызова теряется

// 3) Функции-конструкторы. This в конструкторах и классах - это новый экземпляр объекта
// Внутри функций констукторов контекст вызова для всех методов и свойств будет только что созданный объект, в данном случае ivan. This всегда ссылается на экземпляр, который был создан в new User('Ivan', 28);

function User(name, id){
    // присваиваем уникальное имя и ид при создании пользователя
    this.name = name;
    this.id = id;
    // свойство, которое будет общим для всех
    this.human = true;
    this.hello = function(){
        console.log(`Hello ${name}`);
    }
}

// внутри переменной иван у нас будет храниться не функция, а объект, потомоу что функция юзер у нас стала конструктором и теперь когда она вызывается при помощи new она создает новый объект с теми свойствами, которые мы ей записали
const ivan = new User('Ivan', 28);
ivan.hello(); // Hello ivan

// 4) Ручное присвоение this любой фукнции благодаря call и Apply, bind.
// <--------------------- Call / Apply / Bind ------------------------------>

// Call и Apply отличается лишь тем, что Apply используется, когда функция принимает какие-то дополнительные аргументы

function sayName(surname){
    console.log(this);
    console.log(this.name + surname);
}

const user = {
    name: 'John'
};

// 1) CALL

// в call передаем контекст вызова, который мы хотим передать функции, первым аргументом всегда идет объект. Apply точно так же
// в call мы передаем аргументы через ,
sayName.call(user, 'Smith'); // = 
// { name: 'John' }
//JohnSmith

// 2) Apply

// В apply дополнительные аргументы мы должны уже передавать в массиве (при 2 или более через ,)
sayName.apply(user, ['Somth']); // = 
//{ name: 'John' }
//JohnSomth

// 3) Bind 
// !! Bind создает новую функцию связанную с определенным контекстом. В Call и Apply мы не вызывали новую функцию, только устанавливали контекст (this)

function count(num) {
    return this*num; // 2 передается в this
}
// в эту переменную мы сейчас помещаем новую функцию. Мы обращаемся к существующей функции count и используем bind. В качестве контекста вызова (this) передадим 2, а num будет передаваться в функцию double
const double = count.bind(2);
// double это новая функция, у которой есть жестко привязанный контекст (this)
console.log(double(3)); // = 6
console.log(double(9)); // = 18





// == Пример:

const btn = document.querySelector('button');

btn.addEventListener('click', function(){
    // в таком случае контекстом вызова у нас будет сам элемент, на котором произошло событие, но так работает не всегда
    console.log(this); // = <button></button>
});

// !!! Когда у нас обработчик событий написан в классическом режиме, т.е. не с ()=>, а function(), то контекстом вызовом будет сам элемент, на котором произошло событие. По своему он будет тем же самым, что и e.target
// при () => будет undefiend

// <----------------------- Стрелочные функции и контекст вызова -------------------------->

// Стрелочные функции не имеют собственного контекста вызова (this). Она всегда его будет брать у своего родителя

const obje = {
    num: 5,
    sayNumber: function(){
        // у функции this будет объект, методом которого она является
        const say = () => {
            // у стрелочной функции нет своего this, она ссылается на this родителя
            console.log(this); // = { num: 5, sayNumber: [Function: sayNumber] }
            console.log(this.num); // = 5
            
        }; 
        // функция say обращается к контексту вызова sayNumber. При обычной функции вместо стрелочной был бы undefiend
        say();
    }
};

obje.sayNumber(); // = { num: 5, sayNumber: [Function: sayNumber] }


// пример

const doubleNum = (a) => {
    // return a * 2; это правильно сработает, но стрелочная функциия была разработана, чтобы сокращать наш код, и это можно сократить

}
    // Если наше действие, т.е. тело функции помещается в одну строку, то мы можем  написать его без фигурных скобок, т.е.
    // return подставляется автоматически
    // если стрелочная функция имеет всего 1 аргумент, то можно убрать скобки
const doubleNumm = a => a * 2;