
// <----------------------Алгоритмы поиска на JavaScript-----------------------> \\

"use strict";

// <------Линейный поиск на JavaScript----->

// Алгоритм линейного поиска (linear search) просто по очереди сравнивает элементы заданного списка с ключом поиска до тех пор, пока не будет найден элемент с указанным значением ключа (успешный поиск) или весь список будет проверен, но требуемый элемент не найден (неудачный поиск). Зачастую применяется простой дополнительный прием: если добавить ключ поиска в конец списка, то поиск обязательно будет успешным, следовательно, можно убрать проверку завершения списка в каждой итерации алгоритма. Далее приведен код реализации данного алгоритма на JavaScript; предполагается, что входные данные имеют вид массива.

function LinearSearch(t,A)      // t - искомый элемент,
{                               // A - массив, в котором ищем.
    var n = A.length, i = 0;   
    
    A[n] = t;
    
    while (A[ i ] !== t) {
        i++;
    }
                                
    if (i < n) {
     return i;
    }          // На выходе индекс искомого элемента.
    else { 
        return -1;
    }               // Если искомого элемента нет в массиве, то -1.
}

let arr = [1, 5, 6, 7, 2, 10];
console.log(LinearSearch(2, arr)); // = 4 (позиция в массиве)


// <--------Бинарный (двоичный) поиск на JavaScript------->

// Поиск элемента в отсортированном массиве. Бинарный поиск (binary search) представляет собой в высшей степени эффективный алгоритм для поиска в отсортированном массиве. Он работает путем сравнения искомого ключа t со средним элементом массива A[k]. Если они равны, алгоритм прекращает работу. В противном случае та же операция рекурсивно повторяется для первой половины массива, если t < A[k], и для второй, если t > A[k].

// Стандартная реализация алгоритма бинарного поиска на JavaScript

function BinarySearch(t,A)         // t - искомый элемент,
{                                  // A - упорядоченный массив, в котором ищем.
    var i = 0, j = A.length-1, k;   

    while (i <= j)
    {  k = Math.floor((i+j)/2);
       if (t === A[k]){
            return k;
        }
       else if (t < A[k]) {
           j = k-1;
        }
       else {
            i = k+1;
        }
    }
                                   // На выходе индекс искомого элемента.
    return -1;                     // Если искомого элемента нет в массиве, то -1.
}

// масств обязательно должен быть отсортирован 
let array = [1, 2, 3, 4, 7, 8, 9, 10];
console.log(BinarySearch(8, array)); // = 5 (позиция в массиве)
console.log(BinarySearch(3, array)); // = 2 (позиция в массиве)



// Оптимизированный вариант


function BinarySearchOp(t,A)         // t - искомый элемент,
{                                    // A - упорядоченный массив, в котором ищем.
    var i = 0, j = A.length, k; 
                                 
    while (i < j)                
    {  
        k = Math.floor((i+j)/2);
        if (t <= A[k]) {
           j = k;
        }
        else {
            i = k+1;
        }
    }
   
    if (A[ i ] === t) {
        return i;  
    }                               // На выходе индекс искомого элемента.
    else { 
        return -1;
    }                               // Если искомого элемента нет в массиве, то -1.
}

let Barray = [1, 2, 3, 4, 7, 8, 9, 10];
console.log(BinarySearchOp(8, Barray)); // = 5 (позиция в массиве)
console.log(BinarySearchOp(3, Barray)); // = 2 (позиция в массиве)



// <---------Интерполирующий поиск на JavaScript------------>

// Рассмотрим алгоритм поиска в отсортированном массиве, который называется интерполирующим поиском (interpolation search). В отличие от бинарного поиска, который всегда сравнивает ключ поиска со средним значением отсортированного массива (а следовательно, всегда уменьшает размер задачи вдвое), интерполяционный поиск учитывает значение ключа поиска при определении элемента массива, который будет сравниваться с ключом. В определенном смысле алгоритм имитирует поиск имени в телефонной книге. Если мы ищем в телефонной книге, например, Иванов — вряд ли мы будем открывать ее в средине или ближе к концу, как поступили бы при поиске Петрова.


function InterpolationSearch(t,A)          // t - искомый элемент,
{                                          // A - упорядоченный массив, в котором ищем.
    var mid,
        low = 0,
        high = A.length-1;

    while (A[low] < t && A[high] > t)
    {  
        mid = low + Math.floor( ((t-A[low])*(high-low))/(A[high]-A[low]) );
        if (A[mid] < t) {
           low = mid+1;
        }
        else if (A[mid] > t){ 
            high = mid-1;
        }
        else {
            return mid;
        }
    }

    if (A[low] === t) {
        return low;      
    }                           // На выходе индекс искомого элемента.
    else if (A[high] === t) {
        return high;
    }                           // Если искомого элемента нет в массиве, то -1.
    else {
        return -1;
    }
}

let InterArray = [1, 2, 3, 4, 7, 8, 9, 10, 11, 12, 15, 18];
console.log(InterpolationSearch(15, InterArray)); // = 10 (позиция в массиве)
console.log(InterpolationSearch(3, InterArray)); // = 2 (позиция в массиве)




// <---------------Поиск подстроки на JavaScript-------------------------->

// Формально задачу поиска подстроки (substring search) можно сформулировать следующим образом. Пусть есть некоторый текст str символов с длиной N, и шаблон sub с длиной n (n <= N) в виде строки. Если для некоторого значения i принадлежит [0; N - n+1) выполняется равенство str[i], ..... , str[i+n-1] = sub [0], .... ,sub[n-1], т.е. если для всех i принадлежит  [0; n) справедливо равентсво sub[i] = str [i + j], то будем говорить, что шаблон sub входит в текст str со сдвигом i.
// Задача поиска подстроки состоит в определении сдвига с которым шаблон sub входит в текст str (или установлении тгго факта, что тест не содержит подстроки, соответствующей шаблону). Проще говоря,нужно определить индекс i крайнего слева символа первой соответствующей шаблону sub подстроки в тексте str.
// например, если str = "Lorem ipsum" и sub = "ips", то i = 6

// Простейший алгоритм поиска состоит в непосредственной проверке всех возможных смещений. Проверка заключается в последовательном сравнении символов шаблона \mathsf{sub} с символами строки \mathsf{str}; при первом же обнаруженном несовпадении символов проверка прекращается и переменная внешнего цикла увеличивается на 1.

function SubstringSearch(sub, str)    // sub - искомая подстрока
{                                     // str - строка, в которой ищем
    var i, j, n = sub.length,
        N = str.length - n + 1;
    
    for (i = 0; i < N; i++)
    {  j = 0;
        while (j < n && sub.charAt(j) === str.charAt(i+j)) {
            j++;
        }
        if (j === n) {
           return i;
        }
    }                                // На выходе индекс 1-го символа подстроки.
                                     // Если искомой подстроки нет в строке, то -1.
    return -1;                       // Например,
}                                    // SubstringSearch('ips', 'Lorem ipsum') = 6,
                                     // SubstringSearch('dolor', 'Lorem ipsum') = -1.