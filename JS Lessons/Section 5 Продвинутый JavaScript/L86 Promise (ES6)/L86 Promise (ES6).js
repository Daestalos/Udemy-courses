'use strict';
// Promise - Обещание

// < ---------------------------- Callback Hell ------------------------->

// Когда нам нужно, чтобы выполнение одной функции шло только после выполнения следующей, м используем callback, т.е. функции обратного вызова. Например, запрос на сервер, получаем данные, после этого производим какие-то действия с этими данными и опять их отравляем на сервер, после того как второй раз отправили, опять получаем ответ и что-то делаем опять. Мы можем выполнить действие, только если предыдущее было успешно выполненно. 
// Для такого кода можно написать много функций обратного вызова и это превратится в огромный нечитаемый кусок кода (он же Callback Hell)


// Пример колбэк ада:

console.log('Запрос данных...');

setTimeout(()=>{
    console.log('Подготовка данных...');

    const product = {
        name: 'TV',
        price: 2000
    };

    
    setTimeout(()=>{
        product.status = 'order';
        console.log(product);
    }, 2000);

}, 2000);

// это лишь частичное представление, иногда нам требуется КУДА больше callback'ов, и при этом колбеки не огранициваются только settimeoutом, там могут быть как функции и т.д.

// Для того, чтобы не попадать в callback ад и существуют промисы

// < ------------------------------ Promise -------------------------------->

// Когда мы создаем промис обычно callback функция принимает у нас 2 агрумента, которые обозначают функции, которые мы в будущем можем сами передавать:
// 1. resolve - что-то выполнилось правильно, как мы ожидали. resolve может принимать в себя аргументы (data), чтобы передавать их дальше для методов then и последующей работы с ними.
// 2. reject - промис не выполнился и что-то пошло не так. Мы ее можем получить не только при ошибке, но и так же когда ссылаемся на несуществующий файл, несуществующий сервер или сервер упал и тоже вернул какую-то ошибку. функция будет выполняться, когда у нас произошла ошибка и чтобы обработать эту ошибку мы должны воспользоваться методом catch.
// Иногда если нам reject не нужен (это бывает редко), мы можем передавать только resolve

// У промиса есть несколько методов:
// 1. then - этот метод выполняется на промисе в случае положительного исхода (в случае если код дойдет до resolve() и все в порядке)
// 2. catch - этот метод выполняет при получении функцией reject ошибки. 
// 3. finally - этот метод позволяет выполнить действие при абсолютно любом исходе выполнения промиса, будь то положительно или отрицательно.

// Пример использования:
// Например мы при помощи промиса отправляем данные с формы, нам возвращается обещание, что либо сервер примет данные, либо не примет, соответственно мы можем его обработать при помощи resolve, если все пошло хорошо, то мы какие-то действия выполняем then, если же что-то пошло не так, то мы обрабатываем catch, показываем ошибку пользователю. В finally мы можем поместить участок кода, где мы очищаем форму и не важно успешно она отправилась или нет

// Преимущество перед callback промиса в том, что мы можем возвращать промис из then по цепочке, когда одна синхронная операция выполнится, мы выполним следующую, затем еще следющую и т.п.

// Пример:
console.log('Запрос данных...');
// Создадим промис внутри переменной req и передаем callback функцию [ () => будет тоже самое что и function()]
// Когда мы создаем просис, мы предполагаем, что оно может завершиться как положительно, так и отрицательно, для этого мы передаем 2 аргумента (resolve, reject). По факту это агрументы, вместо которых у нас будут подставляться функции, если все пошло правильно, то мы будем вызывать функцию resolve(), если что-то не так reject();
const req = new Promise(function(resolve, reject){
    // имитация сихронного кода (имитация получения данных с сервера)
    setTimeout(()=>{
        console.log('Подготовка данных...'); // = Подготовка данных...
    
        const product = {
            name: 'TV',
            price: 2000
        };
        // если все в порядке - вызваем resolve();
        // Передаем 
        resolve(product);

    }, 2000);
    
});
// далее как только мы получили все варианты, мы должны обработать как resolve, так и reject
// используем метод промиса then. Он принимает внутри себя тот аргумент с функцией, называемый resolve
req.then( (product) => {
    // product не существует здесь и чтобы передать данные в этот метод мы должны использовать resolve и передать ему product в качестве аргумента. После того как мы передали resolve аргумент, содержащий наши данные, которые вернулись из предыдущего этапа, он будет передаваться then и с ним можно будет работать
    // console.log('Данные получены');
    setTimeout(()=>{
        product.status = 'order';
        console.log(product);
    }, 2000);
})
        
// например после шагов выше нам требуется выполнить еще какие-то действия, для этого мы повторно оборачиваем конструкцию в промис
req.then((product) =>{
    const req2 = new Promise((resolve, reject) =>{
        setTimeout(()=>{
            product.status = 'order';
            resolve(product);
        }, 2000);  
    })

    // product придет в качестве data, ибо мы его передали в resolve
    req2.then(data => {
        console.log(data); // = { name: 'TV', price: 2000, status: 'order' }
    })
})

req.then((product) =>{
    // мы можем не присваивать промис переменной, а написать return, чтобы позвращать новый промис, который может завершиться либо положительно, либо отрицательно
    return new Promise((resolve, reject) =>{
        setTimeout(()=>{
            product.status = 'order';
            // возвращаем данные
            resolve(product);
        }, 2000);  
    }).then(product => { 
        // ИЗ данных callback функций мы можем возвращать не только промисы.
        product.modify = true;
        return product;
        // возвращаем наши данные и дальше мы их можем обрабатывать
    }).then (product =>{
        console.log(product); // = { name: 'TV', price: 2000, status: 'order' }
    });
    // теперь все синхронные операции мы можем выполнять просто по такой цепочке then

})

// <////////// reject, catch, finally \\\\\\\\\\\\\\> - промис не выполнился и что-то пошло не так

req.then((product) =>{
    return new Promise((resolve, reject) =>{
        setTimeout(()=>{
            product.status = 'order';
            // поменяем функцию resolve на reject
            reject(); // функция будет выполняться, когда у нас произошла ошибка и чтобы обработать эту ошибку мы должны воспользоваться методом catch. Если что-то пойдет не так, то мы пропустим все then и перейдем сразу в catch
        }, 2000);  
    }).then(product => { 
        product.modify = true;
        return product;
    }).then (product =>{
        console.log(product); // = { name: 'TV', price: 2000, status: 'order', modify: true }
        
    }).catch(()=>{
        // выполнится при возникновении какой-то ошибки.
        console.error('Произошла ошибка'); // = Произошла ошибка
    }).finally(()=>{
        // выполнится при любом промисе, положительном или отрицательном
        console.log('Finnaly'); // = Finally
    });


})


// <===================== Метод Promise.all([]) =======================>

// Пример: Функция, которая будет запускаться, принимать в себя аргумент time с количеством времени, она возвращает промис, который выполнит resolve через определенное время, которое мы передаем в эту функцию
const test = time =>{
    return new Promise(resolve =>{
        setTimeout( () => resolve(), time )
    });
};
// задаем время выполнения, используем метод then и во внутрь обязательно передаем функцию, которая будет resolve'м
// Такую функцию можно использать чтобы запускать одинаковые операции через определенный промежуток времени
test(1000).then(() =>{ console.log('1000 ms'); });
test(2000).then(() =>{ console.log('2000 ms'); });

// Promise.all - служит для того, чтобы мы точно убедились, что все промесы выполнились успешно (Пример: делать запросы на разные сервера, чтобы получить различные изображения, эти сервера по-разному отвечают, с разным промежутком времени, но мы хотим использовать все изображения как только они ВСЕ загрузятся), т.е. мы должны подождать загрузки всех промисов и только потом что-то делать. Во внутрь себя принимает массив с промисами.

Promise.all([test(1000), test(2000)]).then(()=>{
    console.log('Промисы выполнились'); // выполнится через 3000ms
}).catch(()=>{
    console.log('Что-то пошло не так');
});

// <===================== Метод Promise.race([]) =======================>

// Promise.rase - выполняем действие как только один из прописов правильно отработал, не ожидая другие

Promise.race([test(1000), test(2000)]).then(()=>{
    console.log('Промисы выполнились'); // выполнится через 1000ms
}).catch(()=>{
    console.log('Что-то пошло не так');
});