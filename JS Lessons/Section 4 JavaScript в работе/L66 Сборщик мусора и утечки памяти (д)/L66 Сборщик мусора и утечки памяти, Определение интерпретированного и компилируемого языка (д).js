
// <------------------------------- Интерпритируемый / Компилируемый ------------------------>

// https://nuancesprog.ru/p/12524/

// 1) JS - Высокоуровненный язык програмирования. Многие базовые операции уже за нас реализованы на программном уровне.
// Пример: Работа с оперативной памятью компьютера

// 2) Js - Интерпритируемый язык программирования. Это значит, что программа интерпритатор постройно запускает Js код и будет выполнять его, будь то браузер или терминал.

// Отличия интерпритированного от компилируемого в том, что в компилируемом сначала программа полностью переводится в двоичный код, а затем только выполняется.
// Пример: обычные приложения на компьютере: MSWord, Excel и т.д.


// <--------------------------------- Сборщик мусора ------------------------------->

// https://learn.javascript.ru/garbage-collection

// Сборщик мусора - это такие подпрограммы, которые отслеживают выделение и использование памяти компьютера, и при необходимости они могут автоматически очищать эту память, если какой-то код сейчас не используется

// Сборщик мусора УСЛОВНО автоматически делает это. Почему условно? Потому что такая задача точно определения, что такая-то часть памяти больше не нужна, она алгоритмически не разрешима, поэтому иногда сам разработчик должен решать эти вопросы, иначе могут быть утечки памяти.

// <-------------------------  Учетка памяти  --------------------------->

// Случаи утечек памяти:

// 1) Глобальные переменный (никогда скорее всег оне встретим). Если в коде не стоит use strict, то можно создать переменную без ее объявления

function func(){
    smth = 'string'; // без директивы use strict ошибки не будет, это неправильное поведение
    // во внутренностях бразуера такой код будет интерпритироваться как 
    // window.smth = 'string';
    // такой код значит, что мы создаем лишнюю глобальную переменную, которую мы помещаем в window, она не может быть удалена сборщиком мусора
}

// 2) Забытые таймеры. Проблема в том, что они хранят ссылки на то, с чем мы должны работать

const someRes = getData();
const node = document.querySelector('.class');

setInterval(function(){
    if (node) { 
        node.innerHTML = someRes;
    }
}, 1000);

// Сейчас внутри интервала у нас есть ссылка и на данные, которые могут быть очень большими, а так же ссылка на нашу переменную node, содержащая элемент на старнице. И даже если мы сейчас удалим элемент из DOM-дерева, то он останется в памяти, так как ссылка на него все еще существует до интервала, который срабатывает каждую секунду. Соответсвенно это УТЕЧКА ПАМЯТИ! Память забивается ненужными нам данными

// 3) Обработчик события на несуществующий элементах. Часть из элементов может исчезнуть во время работы сайта, а обработчики останутся и в нем же остается ссылка  на элемент, с которым нужно работать

// !! Современные браузеры будут удалять обработчик событий, если элемент был удален, на который он был повешен

// 4) Замыкание. Теоритечески можно создать случай, когда у нас получится утечка памяти за счет того, что большой объем данных хранится в замыкании функции и не может быть удален.

function outer() {
    const potentiallyHugeArray = [];
    return function inner(){
        potentiallyHugeArray.push('hello');
        console.log('hello!!');
    }

}

const sayHello = outer(); // в переменную запишется новая функция inner, потому что outer возвращает эту функцию. Теперь у нас в sayHello хванится ссылка на замыкание, которое содержит potentiallyHugeArray

// 5) Ссылки на DOM-элементы. Очент часто мы сохраняем ссылки на элементах в переменных JS, одновременно они существуют в DOM, когда мы удаляем объекты из DOM дерева, т.е. в верстве, ссылка на него может оставаться в переменных JS и этот элемент так и будет висеть в памяти.

function createElement() {
    const div = document.createElement('div');
    div.id = 'test';
    return div;
} // когда  функция сработает, у нас будет создан новый div и помещен id test

const testDiv = createElement(); 
document.body.append(testDiv); // поместаим testDiv в body
// в какой-то промежуток времени может встать задача удалить этот блок
// допустим для этог оесть функция
function deleteElement(){
    deleteElement.body.removeChild(document.getElementById('test'));

}

deleteElement(); // deleteElement ориентируется не на какую-то созданную переменную внутри JS кода, а именно на DOM, она находит уникальный ID и по нему удаляем элемент из верстки

// Эта команда удаляет наш этемент просто из DOM дерева, из верстки, а в JS он у нас останется, так как testDiv у нас осталась, она ссылкается на div, который был создан внутри функции createElement и поэтому у нас образовалась небольшая утечка памяти

// Самый просто способ это исправить - поместить testDiv в такие условия, что после поздания она будет удалена. Просто помещая  document.body.append(testDiv); внутри нашей функции 

function createElement() {
    const div = document.createElement('div');
    div.id = 'test';
    document.body.append(testDiv);
}

// так же убираем создание переменной const testDiv = createElement(); 
createElement();
// когда запустится функция createElemen, создается элемент, после этого мы помещаем этот элемен сразу на страницу, когда функция закончит работу, то все то, что внутри, в том числе переменная div они будут очищены сборщиком мусора, потому что ссылки нам эти уже не нужны

// !! Если нам требуется найти утечку памяти, нам в этом может помочь инструмент профилирования, например в гугл хром, или в других браузерах