
// <----------------------- Событие --------------------------->
// Событие - сигнал от браузера о том, что что-то у нас произошло (клик, двойной клик, отправка данный в фотме, прокрутка мыши и т.д.)

// простой список событий: 
// https://oddler.ru/blog/i63

// справочник событий:
// https://developer.mozilla.org/ru/docs/Web/Events

// Чтобы использовать любое событие мы должны назначить обработчик события. Обработчик - это функция, которая срабатывает как только событие произошло (например пользователь совершает щелчок мышью на каком нибудь меню и оно разворачивается)

// <------------ Способы назначить обработчик события ----------------->

// 1) Использовать html-атрибут, который записывается прямо в верстке. И в этот атрибут мы можем передать функцию прямо из JS (не рекомендуется применять)

// Берем какой-либо элемент, на который мы хотим назначить обработчик и прописываем ему событие с приставкой on, например onClick, onChange, раскрываем ковычки и записываем какой-то код

<button onclick='alert("Btn clicked")' id='btn'> Нажми меня </button>

// 2) Использовать свойство DOM-дерева для событий (в реальных проектах такой код тоже почти не используется)

// сначала получаем элемент, на который хотим повесить событие
const btn = document.querySelector('button');
// дальше используем просто свойство DOM-дерева
btn.onclick = function(){
 alert('Btn clicked');
};


// !!! 3) addEventListener / Event / removeEventListener (использовать во всех случаях)

// >----------------  addEventListener ------------------<


// https://developer.mozilla.org/ru/docs/Web/API/EventTarget/addEventListener


// берем элемент, прописываем addEventListener (дословно говорим, что мы назначаем слушатель события, JS следит за этим элементом и если данное событие прозошло - запустит обработчик)
// первым аргументом передаем название события, вторым callback-функцию, которая и будет обрабочиком
btn.addEventListener('click', () => {
    alert('Click');
});

// мы можем назначать сразу несколько действий на одно событие

btn.addEventListener('click', () => {
    alert('Second click');
});

// События в JS выполняются в порядке очереди. Как только у нас новое событие поступило, оно добавляется в очередь вне зависимости от других событий.

btn.addEventListener('mouseenter', () => {
    alert('Hover');
});


// >----------------- Event -------------<

// Когда нам неоходимо получать какие-то данные о том элемете, с которым мы взаимодействуем, например, что за событие сейчас произошло, что за элемент используется, координаты этого элемента. Для этого у нас есть специальный объект Event (событие)

// !!! этот аргумент события передается как аргумент в callback функцию, при чем называть мы его можем как угодно (e, event, по-другому). Если нам требуется передать какие-то еще данные, то мы ставим "," и данные передаем следующими аргументами, первым всегда аргумент события!!!!!!!

btn.addEventListener('mouseenter', (e) => {
    console.log(e); // = MouseEvent (объект с кучей своих методов)
    console.log(e.target); // = <button id='btn'> Нажми меня </button>
    // благодаря target мы можем всячески взаимодействовать с элементом ,например:
    e.target.remove(); // элемент пропадет со страницы при наведении
});


// >------------------- removeEventListener ----------------------<

// иногда нам требуется удалять обработчик события с элемента и для этого у нас есть removeEventListener. Но есть одна загвоздка. Мы должны использовать точно такую же функцию, что мы и назначали (при помощи addEventListener)

const deleteElement = (e) => {
    console.log(e.target);
}
// мы просто говорим, что после наведения выши у нас выполнится функция deleteElement, мы лишь на нее ссылаемся
btn.addEventListener('mouseenter', deleteElement);
btn.removeEventListener('mouseenter', deleteElement);
// на данный момент логика тут такая,что мы назначаем обработчик и потом сразу же его удаляем и если все правильно, на странице у нас ничего не произойдет

// пример: Если i будет 3, то мы убираем обработчик события
let i = 0
const Inc = (e) => {
    console.log(e.target);
    i++
    if (i == 3){
        btn.removeEventListener('click', deleteElement);
    }
}
btn.addEventListener('click', deleteElement);


// <------------------ Всплытие событий --------------------->

// Всплытие событий - когда событие срабатывает сначала на вложенном элементе, а затем иэрархии dom-дерева поднимается вверх 

<div class='overlay'>
    <button id='butn'> Нажми меня </button>
</div>

const butn = document.querySelector('.butn'),
overlay = document.querySelector('.overlay');

const func = (e) => {
    console.log(e.currentTarget);
    console.log(e.type);
}

btn.addEventListener('click', deleteElement); // =   <button id='butn'> Нажми меня </button>
overlay.addEventListener('click', deleteElement); // = <div class='overlay'>...</div>

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <!!----------------- Отмена стандартного поведения в браузере ----------------!1>

// Стандартное поведение - например выделение всего текста на странице при зажатой лкм, переход на ссылку, при нажатии сабмит отправка формы и т.д.

// 1 способ) Вернуть в обработчике события return false (устаревший формат)

// 2 способ) Использование метода, который существует у объекта события

const link = document.querySelector('a');

link.addEventListener('click', (e)=>{
    e.preventDefault(); // отменяем стандартное поведение (например говорим браузеру не переходить по ссылке, а делать какие-то другие действия.)
    //  данный участок кода всегда  помещается в самое начало обработчика событий

    console.log(e.target); // кликнув на ссылку у нас произойдет это действие
});



// <------ Установка обработчика на несколько элементов -------->

const btnss = document.querySelectorAll('button'); // получим псевдомассив
// для того, чтобы навесить обработчик, нам нужно полностью перебрать его и на каждый элемент внутри навесить обработчик


// item - каждая отдельная конпка, которая находится внутри
btnss.forEach( item => {
    btn.addEventListener('click', () =>{
        console.log("Кнопка нажата");
    });
});




// <--------------------- Опции события ----------------------->

// у addEventListener так же существует и 3 аргумент - это объект, в который мы можем передать различные опции

// target.addEventListener(type, listener[, options]);

// 1) type
// Чувствительная к регистру строка, представляющая тип обрабатываемого события.
// 2) listener
// Объект, который принимает уведомление, когда событие указанного типа произошло. Это должен быть объект, реализующий интерфейс EventListener или просто функция JavaScript.
// 3) options Необязательный
// Объект options, который определяет характеристики объекта, прослушивающего событие. Доступны следующие варианты:
//  capture:  Boolean указывает, что события этого типа будут отправлены зарегистрированному обработчику listener перед отправкой на EventTarget, расположенный ниже в дереве DOM.
// once: Boolean указывает, что обработчик должен быть вызван не более одного раза после добавления. Если true, обработчик автоматически удаляется при вызове.
// passive:  Boolean указывает, что обработчик никогда не вызовет preventDefault(). Если всё же вызов будет произведён, браузер должен игнорировать его и генерировать консольное предупреждение. Пример Улучшение производительности прокрутки с помощью passive true
// Non-Standard mozSystemGroup: Boolean указывает, что обработчик должен быть добавлен в системную группу. Доступно только в коде, запущенном в XBL или в расширении Chrome.

target.addEventListener(type, listener, {once: true}); // обработчик сработает только 1 раз