

// <-----------Передача по ссылке---------->

"use strict";

// Если мы работаем с примитивами (строки, числа, логический тип данный), они передаются по значение, т.е. когда мы прописываем, например
// b = a , это автоматически интерпритируется как b = 5, так как a = 5

let a = 5,
    b = a;      // переменная b ссылается на переменную a
b = b + 5;
console.log(a); // = 5
console.log(b); // = 10

// Если мы работаем с какими-то объектами (К объектам у нас относятся и массивы, и функции, и какие-то специфические объекты), то у нас идет уже передача не по значению, а по ссылке.
// т.е. при copy = obj мы не копируем объект, не создаем новый такой же, мы передает значение по ссылке. Это значит, что мы в obj передаем не структуру объекта (какие у него значения, какие параметры), а передаем ссылку на данный объект, т.е. выполняя copy.a = 10 по сути выполняем obj.a = 10

const obj = {
    a: 5,
    b: 1
};

const copy = obj; // передает не структуру объекта, а передает ссылку на него
copy.a = 10; // изменяя что-то внутри copy, мы изменяем наш изначальный объект

console.log(copy); // { a: 10, b: 1 }
console.log(obj); // { a: 10, b: 1 }

// <-------------------- Создание копии объекта и массива-------------------------------------->

// если нам все же требуется не ссылаться на объект, а создать его копию, то для этого существует несколько способов

// <======== (для объекта) первый из них использование цикла: ===========>

const object = {
    a: 5,
    b: 1
};
// при помощи цикла создадим новый объект перебирая свойства старого
// функция скопирует так же и вложенные свойства, но с одним условием, пометка ниже!!!!!!!!!!!!
function copyObj (mainObj) {
    let objCopy = {};


    for (let key in mainObj){
        // берем наш объект objCopy, внутри создаем новое свойство (key), это свойство будет содержать такое же обозначение, как и в главном объекте
        // по сути мы пройдемся по старому объекту, скопируем свойства и помести в новый объект
        objCopy[key] = mainObj[key];
    }

    return objCopy; // возвращаем новый объект, чтобы с ним взаимодействовать
}

// пример
const numbers = {
    a: 2,
    b: 5,
    c: {
        x: 7,
        y: 4
    }
};

// создаем переменную, которая будет нашим новым объектом, затем воспользуемся функцией copyObj, которая вернет нам новый массив, и передадим в функцию объект, который нужно скопировать (numbers)
const newNumbers = copyObj(numbers);
newNumbers.a = 10; 
console.log(numbers); // { a: 2, b: 5, c: { x: 7, y: 4 } }  -  старый объект, изначальый массив не изменен
console.log(newNumbers); // { a: 10, b: 5, c: { x: 7, y: 4 } } - новый объект, копия готова

// но, если мы вдруг захотим изменить вложенное свойство, то увидим, что x изменился как в изначальном объекте, так и в скопированном
newNumbers.c.x = 10;
console.log(numbers); // { a: 2, b: 5, c: { x: 10, y: 4 } }, 
console.log(newNumbers); // { a: 10, b: 5, c: { x: 10, y: 4 } }


// !!!!!!!!! Когда мы клонируем объекты есть 2 очень важных понятия !!!!!!!!!!
// глубокие и поверхностные копии объектов

// >>-------------------------- поверхностная копия объектов ---------------------------<<

// в первом случае мы создали поверхностную копию, она берет все обычные свойства, которые были в изначальном объекте (родителе) и создает независимые структуры (в первом случае мы видели, что при изменении a, он изменялся только в копированном объекте )

// но как только в объекте появляется вложенная структура, например одно из свойства будет содержать объект или массив (свойство c), то это свойство будет иметь ссылочный тип данных
// т.е. при обращении  newNumbers.c.x = 10, мы обращаемся numbers.c.x = 10, потому что там на него сохранилась ссылка

// >>------------------------- глубокая копия объекта -----------------------<<

// будет дальше по курсу в уроке 82

// создадим объект с вложенностью

const pers = {
    name: 'Alex',
    tel: '+744444444',
    parent: {
        mom: 'Olga',
        dad: 'Mike'
    }
}

// делаем глубокую копию объекта
// stringify превратит существующий объект в формат JSON. Parse возьмет JSON и распарсит его обратно в объект JS и поместит его в переменную clone, но при этом будет создан уже полностью глубокий клон, который совершенно не зависит от первоночального объекта
const clone = JSON.parse(JSON.stringify(pers));

clone.parent.mom = 'Ann';
console.log(pers.parent.mom); // Olga
console.log(clone.parent.mom); // Ann


// <============ (для объекта) второй способ метод Object.assign ============>

// Оbject.assign создает независимую копию объекта, которая независит от изначального объекта, так и от добавленного (НЕ СЧИТАЯ ВЛОЖЕННУЮ СТРУКТУРУ, она ссылается на изначальный объект)

// Допустим у нас есть большой какой-то объект, например prevObj и мы внутрь хотим поместить объект поменьше, у которого будет еще несколько свойств, наример d, j или другие прочие

const prevObj = {
    a: 2,
    b: 5,
    c: {
        x: 7,
        y: 4
    }
};

const add = {
    d: 17,
    e: 20
};
// первым аргументом передаем тот объект, в который мы хотим это все поместить (prevObj), вторым агрументом идет тот объект, который мы помещаем (add)
console.log(Object.assign(prevObj, add)); // { a: 2, b: 5, c: { x: 7, y: 4 }, d: 17, e: 20 } ===
// { 
//  a: 2,
//  b: 5, 
//  c: { 
//     x: 7, 
//     y: 4 
//  }, 
//  d: 17, 
//  e: 20 
// }

// тоже самое мы можем создать и с пустым объектом, чтобы сделать копию объекта
// в качестве первого аргумента передаем пустой объект, чтобы копировать в него объект из второго аргумента
const newObject = Object.assign({}, add); 
newObject.d = 10;
console.log(newObject); // { d: 10, e: 20 }
console.log(add); // { d: 17, e: 20 }



// <============ (для масства) третий способ метод slice() ============>

// метод slice принимает в себя 2 аргумента, 1 аргумент "С какого места вырезаем" и 2 аргумент "по какое", при отсутствии аргументов работает от начала и до конца

const oldArray = ['a', 'b', 'c'];
// если оставить просто только oldArray, то создастся ссылка на старый массив, а не скопируется, для копирования добавим метод slice()
const newArray = oldArray.slice();
newArray[1] = 'daa';
console.log(newArray); // [ 'a', 'daa', 'c' ] 
console.log(oldArray); // [ 'a', 'b', 'c' ]


// <============ (для масства) четверный способ оператор Spread ============>

// оператор Spread (оператор Разворота) разворачивает структуру и превращает ее просто в набор данных

const video = ['youtube', 'twitch', 'rutube'],
      blogs = ['worpress', 'livejournal', 'blogger'],
      // использование Spread (...), позволяет вытащить все переменные массива и поместить их виде ...video 
      internet = [...video, ...blogs, 'vk', 'facebook'];

// оператор Spread развенул эти структуры на отдельные элементы 
console.log(internet); // ==
//    [
//     'youtube',
//     'twitch',
//     'rutube',
//     'worpress',
//     'livejournal',
//     'blogger',
//     'vk',
//     'facebook'
//   ]
  

//// пример


function log(a, b, c){
    console.log(a);
    console.log(b);
    console.log(c);
}
const num = [2, 5, 7];
// массив разложится на 3 отдельных элемента благодара Spread
log(...num); // =
// 2
// 5
// 7



///// пример

const array = ['a', 'b'];
const newArrayy = [...array]; // не является ссылкой на массив, копия его
console.log(newArrayy); // = [ 'a', 'b' ]

///// пример

const q = {
    one: 1,
    two: 2
};

const newObj = {...q}; // не является ссылкой на объект, это его копия
console.log(newObj); // { one: 1, two: 2 }
